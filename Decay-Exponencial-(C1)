# Modelo de Decay Exponencial - Decay Exponencial (C1)

## Fundamento matem√°tico

### Ecuaci√≥n de decay
```
R(t) = R‚ÇÄ ¬∑ e^(-Œªt)
```

Donde:
- **R(t)** = Reputaci√≥n/autoridad en el d√≠a t
- **R‚ÇÄ** = Reputaci√≥n inicial (100%)
- **Œª** = Constante de decaimiento
- **t** = Tiempo en d√≠as

### C√°lculo de Œª para 90 d√≠as

Si queremos que la reputaci√≥n decaiga al **5% en 90 d√≠as** (umbral de renovaci√≥n):
```
0.05 = e^(-Œª¬∑90)
ln(0.05) = -Œª¬∑90
Œª = -ln(0.05)/90 ‚âà 0.0333
```

**Vida media** (tiempo para llegar al 50%):
```
t‚ÇÅ/‚ÇÇ = ln(2)/Œª ‚âà 20.8 d√≠as
```

---

## Implementaci√≥n en Solidity
```solidity
// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/access/AccessControl.sol";
import "@openzeppelin/contracts/utils/math/Math.sol";

/**
 * @title ExpertReputationDecay
 * @notice Sistema de decay exponencial para reputaci√≥n de expertos
 * @dev Implementa memoria finita con decaimiento en 90 d√≠as
 */
contract ExpertReputationDecay is AccessControl {
    
    bytes32 public constant ORACLE_ROLE = keccak256("ORACLE_ROLE");
    
    // Constantes del modelo
    uint256 public constant DECAY_LAMBDA = 333; // Œª * 10000 = 0.0333 * 10000
    uint256 public constant LAMBDA_PRECISION = 10000;
    uint256 public constant DECAY_PERIOD = 90 days;
    uint256 public constant RENEWAL_THRESHOLD = 500; // 5% * 10000
    uint256 public constant REPUTATION_PRECISION = 10000; // 100% = 10000
    
    struct Expert {
        uint256 reputation;      // Reputaci√≥n actual (0-10000)
        uint256 lastUpdate;      // Timestamp √∫ltima actualizaci√≥n
        uint256 contributions;   // N√∫mero de contribuciones
        bool active;             // Estado activo/inactivo
    }
    
    mapping(address => Expert) public experts;
    address[] public expertList;
    
    event ReputationDecayed(address indexed expert, uint256 oldReputation, uint256 newReputation);
    event ReputationRestored(address indexed expert, uint256 newReputation);
    event ExpertRemoved(address indexed expert, uint256 finalReputation);
    
    constructor() {
        _grantRole(DEFAULT_ADMIN_ROLE, msg.sender);
        _grantRole(ORACLE_ROLE, msg.sender);
    }
    
    /**
     * @notice Calcula el decay exponencial
     * @param reputation Reputaci√≥n inicial
     * @param timeElapsed Tiempo transcurrido en segundos
     * @return Nueva reputaci√≥n despu√©s del decay
     */
    function calculateDecay(uint256 reputation, uint256 timeElapsed) 
        public 
        pure 
        returns (uint256) 
    {
        if (timeElapsed == 0) return reputation;
        
        // Convertir tiempo a d√≠as (con precisi√≥n)
        uint256 daysElapsed = (timeElapsed * LAMBDA_PRECISION) / 1 days;
        
        // Calcular e^(-Œªt) usando aproximaci√≥n de Taylor
        // e^x ‚âà 1 + x + x¬≤/2! + x¬≥/3! + x‚Å¥/4! (primeros 5 t√©rminos)
        int256 exponent = -int256((DECAY_LAMBDA * daysElapsed) / LAMBDA_PRECISION);
        uint256 decayFactor = exponentialDecay(exponent);
        
        return (reputation * decayFactor) / REPUTATION_PRECISION;
    }
    
    /**
     * @notice Aproximaci√≥n de e^x usando serie de Taylor
     * @param x Exponente (puede ser negativo)
     * @return Resultado * REPUTATION_PRECISION
     */
    function exponentialDecay(int256 x) internal pure returns (uint256) {
        // Implementaci√≥n simplificada para x negativo
        // e^x ‚âà 1 + x + x¬≤/2 + x¬≥/6 + x‚Å¥/24
        
        int256 sum = int256(REPUTATION_PRECISION); // 1
        int256 term = int256(REPUTATION_PRECISION); // t√©rmino actual
        
        for (uint256 i = 1; i <= 8; i++) {
            term = (term * x) / (int256(i) * int256(REPUTATION_PRECISION));
            sum += term;
            
            // Salir si el t√©rmino es despreciable
            if (term < 10 && term > -10) break;
        }
        
        return sum > 0 ? uint256(sum) : 0;
    }
    
    /**
     * @notice Actualiza el decay de un experto
     * @param expertAddress Direcci√≥n del experto
     */
    function updateDecay(address expertAddress) public {
        Expert storage expert = experts[expertAddress];
        require(expert.active, "Expert not active");
        
        uint256 timeElapsed = block.timestamp - expert.lastUpdate;
        uint256 oldReputation = expert.reputation;
        uint256 newReputation = calculateDecay(oldReputation, timeElapsed);
        
        expert.reputation = newReputation;
        expert.lastUpdate = block.timestamp;
        
        emit ReputationDecayed(expertAddress, oldReputation, newReputation);
        
        // Si la reputaci√≥n cae bajo el umbral, desactivar
        if (newReputation < RENEWAL_THRESHOLD) {
            removeExpert(expertAddress);
        }
    }
    
    /**
     * @notice Actualiza todos los expertos activos
     */
    function updateAllExperts() external onlyRole(ORACLE_ROLE) {
        for (uint256 i = 0; i < expertList.length; i++) {
            if (experts[expertList[i]].active) {
                updateDecay(expertList[i]);
            }
        }
    }
    
    /**
     * @notice A√±ade o restaura reputaci√≥n a un experto
     * @param expertAddress Direcci√≥n del experto
     * @param reputationBoost Cantidad a a√±adir (0-10000)
     */
    function boostReputation(address expertAddress, uint256 reputationBoost) 
        external 
        onlyRole(ORACLE_ROLE) 
    {
        updateDecay(expertAddress); // Primero aplicar decay
        
        Expert storage expert = experts[expertAddress];
        
        if (!expert.active) {
            // Reactivar experto
            expert.active = true;
            expert.reputation = reputationBoost;
            expert.lastUpdate = block.timestamp;
            expertList.push(expertAddress);
        } else {
            // Aumentar reputaci√≥n (m√°ximo 100%)
            expert.reputation = Math.min(
                expert.reputation + reputationBoost,
                REPUTATION_PRECISION
            );
        }
        
        expert.contributions++;
        
        emit ReputationRestored(expertAddress, expert.reputation);
    }
    
    /**
     * @notice Elimina un experto del sistema
     * @param expertAddress Direcci√≥n del experto
     */
    function removeExpert(address expertAddress) internal {
        Expert storage expert = experts[expertAddress];
        expert.active = false;
        
        emit ExpertRemoved(expertAddress, expert.reputation);
    }
    
    /**
     * @notice Obtiene la reputaci√≥n actual de un experto (con decay aplicado)
     * @param expertAddress Direcci√≥n del experto
     * @return Reputaci√≥n actual
     */
    function getCurrentReputation(address expertAddress) 
        external 
        view 
        returns (uint256) 
    {
        Expert memory expert = experts[expertAddress];
        if (!expert.active) return 0;
        
        uint256 timeElapsed = block.timestamp - expert.lastUpdate;
        return calculateDecay(expert.reputation, timeElapsed);
    }
    
    /**
     * @notice Obtiene todos los expertos activos
     * @return Lista de direcciones de expertos activos
     */
    function getActiveExperts() external view returns (address[] memory) {
        uint256 activeCount = 0;
        
        // Contar expertos activos
        for (uint256 i = 0; i < expertList.length; i++) {
            if (experts[expertList[i]].active) {
                activeCount++;
            }
        }
        
        // Crear array con expertos activos
        address[] memory activeExperts = new address[](activeCount);
        uint256 index = 0;
        
        for (uint256 i = 0; i < expertList.length; i++) {
            if (experts[expertList[i]].active) {
                activeExperts[index] = expertList[i];
                index++;
            }
        }
        
        return activeExperts;
    }
}
```

---

## Script de visualizaci√≥n en Python
```python
import numpy as np
import matplotlib.pyplot as plt
from datetime import datetime, timedelta

# Par√°metros del modelo
LAMBDA = 0.0333  # Constante de decaimiento
DAYS = 90        # Per√≠odo de an√°lisis
R0 = 100         # Reputaci√≥n inicial (100%)

def reputation_decay(t, r0=R0, lam=LAMBDA):
    """Calcula la reputaci√≥n en el d√≠a t"""
    return r0 * np.exp(-lam * t)

def days_to_threshold(threshold, r0=R0, lam=LAMBDA):
    """Calcula d√≠as necesarios para llegar a un umbral"""
    return -np.log(threshold / r0) / lam

# Generar curva de decay
t = np.linspace(0, DAYS, 1000)
reputation = reputation_decay(t)

# Crear visualizaci√≥n
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(15, 5))

# Gr√°fica 1: Curva de decay completa
ax1.plot(t, reputation, 'b-', linewidth=2, label='Decay exponencial')
ax1.axhline(y=50, color='orange', linestyle='--', label='Vida media (50%)')
ax1.axhline(y=5, color='red', linestyle='--', label='Umbral renovaci√≥n (5%)')
ax1.axvline(x=days_to_threshold(50), color='orange', linestyle=':', alpha=0.5)
ax1.axvline(x=90, color='red', linestyle=':', alpha=0.5)

ax1.set_xlabel('D√≠as', fontsize=12)
ax1.set_ylabel('Reputaci√≥n (%)', fontsize=12)
ax1.set_title('Decay Exponencial - C√°mara de Expertos', fontsize=14, fontweight='bold')
ax1.grid(True, alpha=0.3)
ax1.legend()
ax1.set_xlim(0, DAYS)
ax1.set_ylim(0, 105)

# Agregar anotaciones
ax1.annotate(f'Vida media: {days_to_threshold(50):.1f} d√≠as',
            xy=(days_to_threshold(50), 50),
            xytext=(30, 60),
            arrowprops=dict(arrowstyle='->', color='orange'),
            fontsize=10)

ax1.annotate(f'Renovaci√≥n requerida\n(d√≠a {DAYS})',
            xy=(90, 5),
            xytext=(70, 20),
            arrowprops=dict(arrowstyle='->', color='red'),
            fontsize=10)

# Gr√°fica 2: Comparaci√≥n de diferentes Œª
lambdas = [0.0167, 0.0333, 0.0666]  # Œª lentos, normal, r√°pido
labels = ['Lento (180 d√≠as)', 'Normal (90 d√≠as)', 'R√°pido (45 d√≠as)']
colors = ['green', 'blue', 'red']

for lam, label, color in zip(lambdas, labels, colors):
    rep = reputation_decay(t, lam=lam)
    ax2.plot(t, rep, linewidth=2, label=label, color=color)

ax2.axhline(y=5, color='gray', linestyle='--', alpha=0.5, label='Umbral (5%)')
ax2.set_xlabel('D√≠as', fontsize=12)
ax2.set_ylabel('Reputaci√≥n (%)', fontsize=12)
ax2.set_title('Comparaci√≥n de Velocidades de Decay', fontsize=14, fontweight='bold')
ax2.grid(True, alpha=0.3)
ax2.legend()
ax2.set_xlim(0, DAYS)
ax2.set_ylim(0, 105)

plt.tight_layout()
plt.savefig('expert_decay_model.png', dpi=300, bbox_inches='tight')
plt.show()

# Tabla de valores clave
print("\n=== MODELO DE DECAY EXPONENCIAL ===\n")
print(f"Constante Œª: {LAMBDA}")
print(f"Per√≠odo de renovaci√≥n: {DAYS} d√≠as")
print(f"Reputaci√≥n inicial: {R0}%\n")

milestones = [0, 7, 14, 21, 30, 45, 60, 75, 90]
print("D√≠a\tReputaci√≥n\tDecay")
print("-" * 35)
for day in milestones:
    rep = reputation_decay(day)
    decay = ((R0 - rep) / R0) * 100
    print(f"{day}\t{rep:.2f}%\t\t-{decay:.1f}%")

print(f"\nVida media (50%): {days_to_threshold(50):.1f} d√≠as")
print(f"Umbral renovaci√≥n (5%): {days_to_threshold(5):.1f} d√≠as")
```

---

## Tabla de decay por d√≠a

| D√≠a | Reputaci√≥n | Decay acumulado | Estado |
|-----|-----------|-----------------|--------|
| 0   | 100.0%    | 0%              | ‚úÖ Inicial |
| 7   | 79.2%     | 20.8%           | ‚úÖ Activo |
| 14  | 62.7%     | 37.3%           | ‚úÖ Activo |
| 21  | 49.7%     | 50.3%           | ‚ö†Ô∏è Vida media |
| 30  | 36.8%     | 63.2%           | ‚ö†Ô∏è Atenci√≥n |
| 45  | 22.3%     | 77.7%           | ‚ö†Ô∏è Cr√≠tico |
| 60  | 13.5%     | 86.5%           | ‚ö†Ô∏è Muy bajo |
| 75  | 8.2%      | 91.8%           | üî¥ Cerca del umbral |
| 90  | 5.0%      | 95.0%           | üî¥ Renovaci√≥n requerida |

---

## Mecanismos de renovaci√≥n

### 1. Renovaci√≥n por contribuci√≥n
```solidity
function contributeReview(address expert, uint256 qualityScore) external {
    // qualityScore: 0-100 basado en m√©tricas de validaci√≥n
    uint256 boost = (qualityScore * REPUTATION_PRECISION) / 100;
    boostReputation(expert, boost);
}
```

### 2. Renovaci√≥n por consenso

- Si **C2 (Comunes)** valida positivamente una revisi√≥n de **C1 (Expertos)**
- Se otorga un boost del 20% (2000 puntos)

### 3. Renovaci√≥n por auditor√≠a externa

- Validaci√≥n por or√°culo externo
- Boost del 30% (3000 puntos)

---

## Par√°metros configurables
```javascript
const DECAY_CONFIGS = {
  // Configuraci√≥n conservadora (decay lento)
  conservative: {
    lambda: 0.0167,
    period: 180,  // d√≠as
    threshold: 0.05
  },
  
  // Configuraci√≥n est√°ndar (recomendada)
  standard: {
    lambda: 0.0333,
    period: 90,   // d√≠as
    threshold: 0.05
  },
  
  // Configuraci√≥n agresiva (decay r√°pido)
  aggressive: {
    lambda: 0.0666,
    period: 45,   // d√≠as
    threshold: 0.10
  }
};
```

---

## Tests en Hardhat
```javascript
const { expect } = require("chai");
const { ethers } = require("hardhat");

describe("ExpertReputationDecay", function () {
  let contract;
  let owner, expert1, expert2;

  beforeEach(async function () {
    [owner, expert1, expert2] = await ethers.getSigners();
    const Contract = await ethers.getContractFactory("ExpertReputationDecay");
    contract = await Contract.deploy();
  });

  it("Should decay reputation exponentially", async function () {
    // Dar reputaci√≥n inicial
    await contract.boostReputation(expert1.address, 10000); // 100%
    
    // Avanzar 21 d√≠as
    await ethers.provider.send("evm_increaseTime", [21 * 24 * 60 * 60]);
    await ethers.provider.send("evm_mine");
    
    // Actualizar decay
    await contract.updateDecay(expert1.address);
    
    const reputation = await contract.getCurrentReputation(expert1.address);
    
    // Debe estar cerca del 50% (vida media ~20.8 d√≠as)
    expect(reputation).to.be.closeTo(5000, 200); // 50% ¬± 2%
  });

  it("Should remove expert below threshold", async function () {
    await contract.boostReputation(expert1.address, 10000);
    
    // Avanzar 90 d√≠as
    await ethers.provider.send("evm_increaseTime", [90 * 24 * 60 * 60]);
    await ethers.provider.send("evm_mine");
    
    await contract.updateDecay(expert1.address);
    
    const expert = await contract.experts(expert1.address);
    expect(expert.active).to.be.false;
  });

  it("Should restore reputation with boost", async function () {
    await contract.boostReputation(expert1.address, 5000); // 50%
    
    // Avanzar 30 d√≠as
    await ethers.provider.send("evm_increaseTime", [30 * 24 * 60 * 60]);
    
    // Nueva contribuci√≥n
    await contract.boostReputation(expert1.address, 3000); // +30%
    
    const reputation = await contract.getCurrentReputation(expert1.address);
    expect(reputation).to.be.gte(3000); // Al menos 30%
  });
});
```

---

## Integraci√≥n con el Valle de Resiliencia
```solidity
/**
 * @notice Calcula el √≠ndice R de la C√°mara de Expertos
 * @return R = œÑ √ó Œ© (debe estar entre 1 y 3)
 */
function calculateResilienceIndex() external view returns (uint256) {
    uint256 activeExperts = getActiveExperts().length;
    if (activeExperts == 0) return 0;
    
    uint256 avgReputation = 0;
    address[] memory experts = getActiveExperts();
    
    for (uint256 i = 0; i < experts.length; i++) {
        avgReputation += getCurrentReputation(experts[i]);
    }
    avgReputation /= activeExperts;
    
    // œÑ (memoria) = reputaci√≥n promedio normalizada (0-3)
    uint256 tau = (avgReputation * 3) / REPUTATION_PRECISION;
    
    // Œ© (frecuencia) = n√∫mero de expertos activos normalizado
    uint256 omega = activeExperts > 10 ? 3 : (activeExperts * 3) / 10;
    
    // R = œÑ √ó Œ© (con precisi√≥n)
    return (tau * omega) / 3;
}
```

---

Este modelo implementa el principio de **Memoria Finita** obligando a los expertos a mantenerse activos y relevantes mediante contribuciones constantes. ¬øQuieres que ajuste alg√∫n par√°metro o agregue funcionalidades adicionales?
